// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: user_group.sql

package repositories

import (
	"context"
	"time"
)

const addMemberToGroup = `-- name: AddMemberToGroup :exec
INSERT INTO "user_group" (
  user_id,
  group_id,
  role,
  status
) VALUES (
  $1, $2, $3, $4
) ON CONFLICT (user_id, group_id) DO UPDATE SET status = $4
`

type AddMemberToGroupParams struct {
	UserID  string `json:"user_id"`
	GroupID string `json:"group_id"`
	Role    string `json:"role"`
	Status  string `json:"status"`
}

func (q *Queries) AddMemberToGroup(ctx context.Context, arg AddMemberToGroupParams) error {
	_, err := q.db.ExecContext(ctx, addMemberToGroup,
		arg.UserID,
		arg.GroupID,
		arg.Role,
		arg.Status,
	)
	return err
}

const getRoleInGroup = `-- name: GetRoleInGroup :one
SELECT role
FROM "user_group"
WHERE user_id = $1 AND group_id = $2
`

type GetRoleInGroupParams struct {
	UserID  string `json:"user_id"`
	GroupID string `json:"group_id"`
}

func (q *Queries) GetRoleInGroup(ctx context.Context, arg GetRoleInGroupParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getRoleInGroup, arg.UserID, arg.GroupID)
	var role string
	err := row.Scan(&role)
	return role, err
}

const getUserGroup = `-- name: GetUserGroup :one
SELECT user_id, group_id, role, status, created_at
FROM "user_group"
WHERE user_id = $1 AND group_id = $2
`

type GetUserGroupParams struct {
	UserID  string `json:"user_id"`
	GroupID string `json:"group_id"`
}

func (q *Queries) GetUserGroup(ctx context.Context, arg GetUserGroupParams) (UserGroup, error) {
	row := q.db.QueryRowContext(ctx, getUserGroup, arg.UserID, arg.GroupID)
	var i UserGroup
	err := row.Scan(
		&i.UserID,
		&i.GroupID,
		&i.Role,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const listEmailInGroup = `-- name: ListEmailInGroup :many
SELECT u.email
FROM "user_group" ug
INNER JOIN "user" u using (user_id)
WHERE group_id = $1
AND ug.status = 'joined'
ORDER BY u.email
`

func (q *Queries) ListEmailInGroup(ctx context.Context, groupID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listEmailInGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var email string
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupJoined = `-- name: ListGroupJoined :many
SELECT g.group_id, group_name, ug.role, created_by, g.created_at
FROM "user_group" ug
INNER JOIN "group" g using (group_id)
WHERE user_id = $1
AND ug.status = 'joined'
AND ug.role != 'owner'
ORDER BY g.group_id
`

type ListGroupJoinedRow struct {
	GroupID   string    `json:"group_id"`
	GroupName string    `json:"group_name"`
	Role      string    `json:"role"`
	CreatedBy string    `json:"created_by"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) ListGroupJoined(ctx context.Context, userID string) ([]ListGroupJoinedRow, error) {
	rows, err := q.db.QueryContext(ctx, listGroupJoined, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGroupJoinedRow{}
	for rows.Next() {
		var i ListGroupJoinedRow
		if err := rows.Scan(
			&i.GroupID,
			&i.GroupName,
			&i.Role,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemberInGroup = `-- name: ListMemberInGroup :many
SELECT user_id, role, status
FROM "user_group"
WHERE group_id = $1
ORDER BY user_id
`

type ListMemberInGroupRow struct {
	UserID string `json:"user_id"`
	Role   string `json:"role"`
	Status string `json:"status"`
}

func (q *Queries) ListMemberInGroup(ctx context.Context, groupID string) ([]ListMemberInGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, listMemberInGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMemberInGroupRow{}
	for rows.Next() {
		var i ListMemberInGroupRow
		if err := rows.Scan(&i.UserID, &i.Role, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMemberFromGroup = `-- name: RemoveMemberFromGroup :exec
DELETE FROM "user_group"
WHERE user_id = $1 AND group_id = $2
`

type RemoveMemberFromGroupParams struct {
	UserID  string `json:"user_id"`
	GroupID string `json:"group_id"`
}

func (q *Queries) RemoveMemberFromGroup(ctx context.Context, arg RemoveMemberFromGroupParams) error {
	_, err := q.db.ExecContext(ctx, removeMemberFromGroup, arg.UserID, arg.GroupID)
	return err
}

const updateMemberRole = `-- name: UpdateMemberRole :exec
UPDATE "user_group"
SET role = $3
WHERE user_id = $1 AND group_id = $2
`

type UpdateMemberRoleParams struct {
	UserID  string `json:"user_id"`
	GroupID string `json:"group_id"`
	Role    string `json:"role"`
}

func (q *Queries) UpdateMemberRole(ctx context.Context, arg UpdateMemberRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateMemberRole, arg.UserID, arg.GroupID, arg.Role)
	return err
}

const updateMemberStatus = `-- name: UpdateMemberStatus :exec
UPDATE "user_group"
SET status = $3
WHERE user_id = $1 AND group_id = $2
`

type UpdateMemberStatusParams struct {
	UserID  string `json:"user_id"`
	GroupID string `json:"group_id"`
	Status  string `json:"status"`
}

func (q *Queries) UpdateMemberStatus(ctx context.Context, arg UpdateMemberStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMemberStatus, arg.UserID, arg.GroupID, arg.Status)
	return err
}
